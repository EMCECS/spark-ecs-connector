buildscript {
    repositories {
        jcenter() // for shadow plugin
    }
}

plugins {
    id 'scala' // for Scala build support
    id 'com.github.johnrengelman.shadow' version '1.2.3' // to build an uber jar
    id 'maven-publish'
    id 'signing'
    id 'maven'
}

ext {
    versions = [:]
}

group 'com.emc.ecs'
version '1.5-SNAPSHOT'

/**
 * Sources
 */
sourceCompatibility = "1.8"

sourceSets {
    intTest {
        compileClasspath += sourceSets.main.output + sourceSets.main.compileClasspath  //+ sourceSets.test.output
    }
}

/**
 * Dependencies
 */
versions += [
        scala     : "2.11",
        scalaPatch: "1",
        spark     : "2.0.1"
]

repositories {
    mavenLocal()
    mavenCentral()
}

dependencies {
    compile("com.emc.ecs:object-client:3.0.1") {
        exclude group: "org.slf4j", module: "slf4j-api"
        exclude group: "org.slf4j", module: "slf4j-log4j12"
    }

    compileOnly "org.apache.spark:spark-core_$versions.scala:$versions.spark",
            "org.apache.spark:spark-sql_$versions.scala:$versions.spark"

    // 'testCompile' dependencies for unit tests
    testCompile "org.scalatest:scalatest_$versions.scala:2.2.6"
    testCompile "org.apache.spark:spark-core_$versions.scala:$versions.spark",
                "org.apache.spark:spark-sql_$versions.scala:$versions.spark"

    // 'intTestCompile' dependencies match a client's use of the shaded jar
    intTestCompile "junit:junit:4.10"
    intTestCompile "org.scalatest:scalatest_$versions.scala:2.2.6"
    intTestCompile "org.apache.spark:spark-core_$versions.scala:$versions.spark",
                   "org.apache.spark:spark-sql_$versions.scala:$versions.spark"
}

/**
 * Publishing
 */
jar.enabled = false

shadowJar {
    baseName "${project.name}_${versions.scala}"
    classifier ""
    relocate 'org.apache.commons', 'com.emc.ecs.shaded.org.apache.commons'
    relocate 'com.sun.ws.rs', 'com.emc.ecs.shaded.com.sun.ws.rs'
    relocate 'javax.ws.rs', 'com.emc.ecs.shaded.javax.ws.rs'
    relocate 'org.apache.http', 'com.emc.ecs.shaded.org.apache.http'
    relocate 'com.sun.jersey', 'com.emc.ecs.shaded.com.sun.jersey'
    relocate 'org.jdom2', 'com.emc.ecs.shaded.org.jdom2'
    relocate 'SevenZip', 'com.emc.ecs.shaded.SevenZip'
    mergeServiceFiles()
}

assemble.dependsOn(shadowJar)

publishing {
    publications {
        shadow(MavenPublication) {
            artifactId "${project.name}_${versions.scala}"
            from components.shadow
        }
    }
}

/**
 * Maven Central
 */
gradle.taskGraph.whenReady { taskGraph ->
    Thread.sleep(500) // trying to get rid of a bug where build status message overwrites the first prompt
    if (taskGraph.hasTask(':uploadJars')) {
        if (!project.hasProperty('signingPass')) {
            project.ext.signingPass = new String(System.console().readPassword('\nSigning key passphrase: '))
        }
        if (!project.hasProperty('sonatypeUsername')) {
            project.ext.sonatypeUsername = new String(System.console().readLine('\nSonatype username: '))
        }
        if (!project.hasProperty('sonatypePass')) {
            project.ext.sonatypePass = new String(System.console().readPassword('\nSonatype password: '))
        }
        ext.'signing.keyId' = 'A4385DAD'
        ext.'signing.secretKeyRingFile' = '/home/signer/.gnupg/secring.gpg'
        ext.'signing.password' = project.ext.signingPass
        uploadJars.repositories.mavenDeployer.repository.authentication.userName = project.ext.sonatypeUsername
        uploadJars.repositories.mavenDeployer.repository.authentication.password = project.ext.sonatypePass
    }
}

configurations {
    jars.extendsFrom(signatures)
}

javadoc {
    if (JavaVersion.current() >= JavaVersion.VERSION_1_8) options.addStringOption('Xdoclint:none', '-quiet')
    else options.quiet()
}

task javadocJar(type: Jar) {
    classifier = 'javadoc'
    from "${docsDir}/javadoc"
}
javadocJar.dependsOn javadoc

task sourcesJar(type: Jar) {
    classifier = 'sources'
    from sourceSets.main.allSource
}

artifacts {
    jars shadowJar
    jars javadocJar
    jars sourcesJar
}

signing {
    required { gradle.taskGraph.hasTask(':uploadJars') }
    sign configurations.jars
}

def projectPom = {
    project {
        name project.name
        description 'The spark-ecs-s3 project makes it possible to work with data stored in ECS using Apache Spark.'
        url 'https://github.com/EMCECS/spark-ecs-s3'

        scm {
            url "https://github.com/EMCECS/${project.name}"
            connection "scm:git@github.com:EMCECS/${project.name}.git"
            developerConnection "scm:git@github.com:EMCECS/${project.name}.git"
        }

        licenses {
            license {
                name 'The Apache Software License, Version 2.0'
                url 'http://www.apache.org/licenses/LICENSE-2.0.txt'
                distribution 'repo'
            }
        }

        developers {
            developer {
                id 'EMCECS'
                name 'EMC ECS'
            }
        }
    }
}

uploadJars {
    repositories {
        mavenDeployer {
            beforeDeployment { MavenDeployment deployment -> signing.signPom(deployment) }

            repository(url: 'https://oss.sonatype.org/service/local/staging/deploy/maven2/') {
                authentication(userName: '', password: '')
            }

            pom projectPom

            pom.scopeMappings.addMapping(1000, configurations.compileOnly, 'provided')
            pom.whenConfigured { pom ->
                pom.dependencies.removeAll { it.scope != 'provided' }
            }
        }
    }
}

/**
 * Testing
 */
task intTest(type: Test, group: "Test") {
    testClassesDir = sourceSets.intTest.output.classesDir
    classpath = files(shadowJar.outputs) + sourceSets.intTest.runtimeClasspath
    systemProperties project.properties.subMap(["s3.endpoint", "s3.accessKeyId", "s3.secretAccessKey"])

    systemProperty "com.emc.ecs.shaded.org.apache.commons.logging.Log","com.emc.ecs.shaded.org.apache.commons.logging.impl.Log4JLogger"

    onlyIf(new Spec<Task>() {
        @Override
        boolean isSatisfiedBy(Task task) {
            return project.properties.containsKey("s3.endpoint") &&
                    project.properties.containsKey("s3.accessKeyId") &&
                    project.properties.containsKey("s3.secretAccessKey")
        }
    })
}
